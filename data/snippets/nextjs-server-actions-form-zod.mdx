---
title: "Next.js Server Actions with Form Handling and Zod Validation"
heading: "Next.js Server Actions with Form Handling and Zod Validation"
icon: "Nextjs"
date: "2025-11-18"
lastmod: "2025-11-18"
tags: ["nextjs", "server-actions", "forms", "zod", "validation", "typescript"]
draft: false
summary: "Complete form handling using Next.js Server Actions with Zod validation, useActionState hook, and progressive enhancement."
images: []
authors: ["Dana"]
---

# Next.js Server Actions with Form Handling and Zod Validation

A modern approach to handling forms in Next.js using Server Actions, the useActionState hook, and Zod for validation. This pattern provides type-safe form handling with excellent UX.

## Installation

```bash
npm install zod
```

## Server Action with Zod Validation

Create a server action file (e.g., `actions/form-action.ts`):

```typescript
"use server";

import { z } from "zod";

const schema = z.object({
  email: z.string().email("Invalid email address"),
  name: z.string().min(2, "Name must be at least 2 characters"),
  message: z.string().min(10, "Message must be at least 10 characters"),
});

export type FormState = {
  message: string;
  errors?: {
    email?: string[];
    name?: string[];
    message?: string[];
  };
  success?: boolean;
};

export async function submitContactForm(
  prevState: FormState,
  formData: FormData
): Promise<FormState> {
  // Convert FormData to object
  const dataToValidate = Object.fromEntries(formData.entries());

  // Validate with Zod
  const validation = schema.safeParse(dataToValidate);

  if (!validation.success) {
    return {
      message: "Validation failed",
      errors: validation.error.flatten().fieldErrors,
      success: false,
    };
  }

  try {
    // Process the validated data
    const { email, name, message } = validation.data;

    // Example: Save to database
    // await db.contact.create({ data: { email, name, message } })

    // Example: Send email
    // await sendEmail({ to: email, subject: 'Thank you', body: message })

    return {
      message: "Form submitted successfully!",
      success: true,
    };
  } catch (error) {
    return {
      message: "Something went wrong. Please try again.",
      success: false,
    };
  }
}
```

## Form Component with useActionState

```typescript
'use client'

import { useActionState } from 'react'
import { submitContactForm, type FormState } from './actions/form-action'

const initialState: FormState = {
  message: '',
}

export default function ContactForm() {
  const [state, formAction, isPending] = useActionState(
    submitContactForm,
    initialState
  )

  return (
    <form action={formAction} className="space-y-4">
      <div>
        <label htmlFor="name" className="block text-sm font-medium">
          Name
        </label>
        <input
          type="text"
          id="name"
          name="name"
          required
          className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
          aria-describedby="name-error"
        />
        {state.errors?.name && (
          <p id="name-error" className="mt-1 text-sm text-red-600">
            {state.errors.name[0]}
          </p>
        )}
      </div>

      <div>
        <label htmlFor="email" className="block text-sm font-medium">
          Email
        </label>
        <input
          type="email"
          id="email"
          name="email"
          required
          className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
          aria-describedby="email-error"
        />
        {state.errors?.email && (
          <p id="email-error" className="mt-1 text-sm text-red-600">
            {state.errors.email[0]}
          </p>
        )}
      </div>

      <div>
        <label htmlFor="message" className="block text-sm font-medium">
          Message
        </label>
        <textarea
          id="message"
          name="message"
          required
          rows={4}
          className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
          aria-describedby="message-error"
        />
        {state.errors?.message && (
          <p id="message-error" className="mt-1 text-sm text-red-600">
            {state.errors.message[0]}
          </p>
        )}
      </div>

      <button
        type="submit"
        disabled={isPending}
        className="w-full rounded-md bg-blue-600 px-4 py-2 text-white hover:bg-blue-700 disabled:opacity-50"
      >
        {isPending ? 'Submitting...' : 'Submit'}
      </button>

      {state.message && (
        <div
          className={`mt-4 rounded-md p-4 ${
            state.success ? 'bg-green-50 text-green-800' : 'bg-red-50 text-red-800'
          }`}
        >
          {state.message}
        </div>
      )}
    </form>
  )
}
```

## Advanced: With Cache Revalidation

```typescript
"use server";

import { revalidatePath } from "next/cache";
import { redirect } from "next/navigation";
import { z } from "zod";

const postSchema = z.object({
  title: z.string().min(1, "Title is required"),
  content: z.string().min(10, "Content must be at least 10 characters"),
});

export async function createPost(prevState: any, formData: FormData) {
  const validation = postSchema.safeParse(
    Object.fromEntries(formData.entries())
  );

  if (!validation.success) {
    return {
      message: "Validation failed",
      errors: validation.error.flatten().fieldErrors,
    };
  }

  try {
    const { title, content } = validation.data;

    // Save to database
    // const post = await db.post.create({ data: { title, content } })

    // Revalidate the cache
    revalidatePath("/posts");

    // Redirect to the new post (if needed)
    // redirect(`/posts/${post.id}`)

    return { message: "Post created successfully!", success: true };
  } catch (error) {
    return { message: "Failed to create post", success: false };
  }
}
```

## Features

- **Type-safe validation** with Zod
- **Progressive enhancement** - works without JavaScript
- **Server-side security** - validation happens on the server
- **Built-in pending states** with useActionState
- **Automatic form reset** after successful submission
- **Cache revalidation** for real-time updates
- **Error handling** with granular field-level errors

## Benefits

- No need for separate API routes
- Reduced client-side JavaScript
- Better security (sensitive logic stays on server)
- Excellent SEO and accessibility
- Single network roundtrip for form submission
